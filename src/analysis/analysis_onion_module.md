# Onion Module - Analysis

This is an excerpt from the specification which we decided to analyze thoroughly: 

> The Onion module deals with constructing onion tunnels for tunnelling data streams from
CM/UI module. In our application, at the end of each round (e.g. round n) the Onion
module on each peer should start constructing a tunnel for the next round (round n + 1)
with at least two intermediate hops which are selected at random. This means that on an
average each peer can expect to be used as an intermediate hop by at least two other peers.

> The destination of a tunnel could be the call recipient or a random peer. This is decided in
the current round (round n) by the CM/UI module. If the CM/UI module has asked Onion
to create a tunnel to a peer, it will be this peer; if not, it will be a random peer selected
by the Onion module with the help of RPS module.

>  The actual round duration is arbitrary
but fixed between all peers, using the same Onion module. Configuration could be realized
by adding another configuration file option.

> The Onion module should read its peer’s hostkey from the file given in the configuration.
It should then listen on a predefined network socket and should accept P2P connections
from Onion modules of other peers from this socket. The Onion modules of two peers use
their respective hostkeys to form an ephemeral session key which they then use to encrypt
all communication between them

> Tunnel building is done iteratively, i.e., a peer \\(O\\) building a tunnel selects the first hop
peer  at random (from RPS), it then forms an ephemeral session key \\(K_1\\)with the peer.
It then uses \\(K_1\\) to encrypt necessary meta-data to H1 to instruct it to connect to the next
hop peer \\(H_2\\) and establish an ephemeral session key \\(K_2\\). Note that \\(K_2\\) is generated by the
hostkeys of \\(O\\) and \\(K_2\\) so that \\(H_1\\) does not learn about it. The process continues until the
tunnel has enough number of hops and the destination peer is added.

> While building the onion tunnels there is a chance that attacker peers are picked at
random. Building a tunnel through them has the disadvantage that if all of the peers in
the tunnel are attacker peers or co-operate among themselves, our communication can be
de-anonymised. Thus, the more peers participate in the tunnel the smaller the risk, as a
single honest peer in the tunnel is enough to scramble your communication. On the other
hand, having more peers increases the latency of the communication and may effect the call
quality. For this reason, we restrict to a hop count of 2 hops in a tunnel (the 3rd hop being
the destination). Combined with cover traffic, small duration of rounds, and end-to-end
encryption between the caller and the callee, even with attacker peers in the tunnel, the
attacker still has to overcome the dilemma whether the traffic observed is cover traffic or
real traffic. The actual hop count may be parameterised via configuration.

> Since we are building an application employing anonymity, it is important to defend
against certain types of traffic analysis attacks which make use of packet sizes to analyze
communication, even though it is encrypted. For this reason, the Onion to Onion communication should employ packets of fixed sizes. The size of the packet is up to the module
developer to decide. It is wise to choose neither of a too big nor too small value. This also
means that packets should be padded accordingly at each hop to maintain their fixed size.
The packet size should be strictly enforced by the protocol — any peer deviating from this
should be disconnected immediately.

> The tunnels the Onion modules build may have unrealiability metrics similar to that of
the UDP protocol. This means that the Onion modules put their best effort in forwarding
the packets but no guarantees need to be made on packet delivery: packets may be lost,
delayed arbitrarily and/or received out of order. If a module requires TCP-style reliability
for the tunnelled data, the module has to employ its own protocol, e.g., by using a userspace
TCP stack.

> Tunnels created in one period should be torn down and rebuilt for the next period.
However, Onion should ensure that this is done transparently to the modules, using these
tunnels. This could be achieved by creating a new tunnel before the end of a period and
seamlessly switching over the data stream to the new tunnel once at the end of the current
period. Since the destination peer of both old and new tunnel remains the same, the seamless
switch over is possible.

> The configuration for Onion should have the following standard parameters:
> - p2p port: This is the port for Onion’s P2P protocol i.e., the port number on which
Onion accepts tunnel connections from Onion modules of other peers. This is different
from the port where it listens for API connections. This value is used by the RPS
module to advertise the socket the onion module is listening on, so that other peers’
onion modules can connect to it.
>- p2p hostname: Similar to p2p port this parameter determines the interface on which
Onion listens for incoming P2P connections.